// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Music info
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 0.0.1
 */

package openapi

import (
	"context"
	"errors"
	"log/slog"
	"net/http"
	"time"

	"github.com/donskova1ex/effective_mobile/internal"
	"github.com/donskova1ex/effective_mobile/internal/domain"
)
type SongsProcessor interface {
	GetSong(ctx context.Context, groupName, songName string) (*domain.Song, error)
	CreateSong(ctx context.Context, song *domain.Song) (*domain.Song, error)
	UpdateSong(ctx context.Context, song *domain.Song) (*domain.Song, error)
	DeleteSong(ctx context.Context, groupName, songName string) error
}
// DefaultAPIService is a service that implements the logic for the DefaultAPIServicer
// This service should implement the business logic for every endpoint for the DefaultAPI API.
// Include any external packages or services that will be required by this service.
type DefaultAPIService struct {
	songsProcessor SongsProcessor
	logger         *slog.Logger
}

// NewDefaultAPIService creates a default api service
func NewDefaultAPIService(songsProcessor SongsProcessor, logger *slog.Logger) *DefaultAPIService {
	return &DefaultAPIService{
		songsProcessor: songsProcessor,
		logger:         logger,
		}
}

// InfoGet - Get song details
func (s *DefaultAPIService) InfoGet(ctx context.Context, group string, song string) (ImplResponse, error) {

	resultSong, err := s.songsProcessor.GetSong(ctx, group, song)
	if errors.Is(err, internal.ErrBadRequest) {
		return Response(http.StatusBadRequest, nil), err
	}
	if errors.Is(err, internal.ErrNotFound) {
		return Response(http.StatusNotFound, nil), err
	}
	if errors.Is(err, internal.ErrEmptyParams) {
		return Response(http.StatusInternalServerError, nil), err
	}
	openApiSong := SongDetail{
		ReleaseDate: resultSong.ReleaseDate.Format("2006-01-02"),
		Text:        resultSong.Text,
		Link:        resultSong.Link,
	}
	return Response(http.StatusOK, openApiSong), nil
}

// InfoPut - Update an existing song
func (s *DefaultAPIService) InfoPut(ctx context.Context, group string, song string, songDetail SongDetail) (ImplResponse, error) {
	releaseDate, err := time.Parse("2006-01-02", songDetail.ReleaseDate)
	if err != nil {
		return Response(http.StatusBadRequest, nil), err
	}

	resultSong, err := s.songsProcessor.UpdateSong(ctx, &domain.Song{
		GroupName:   group,
		SongName:    song,
		ReleaseDate: releaseDate,
		Text:        songDetail.Text,
		Link:        songDetail.Link,
	})
	if err != nil {
		if errors.Is(err, internal.ErrNotFound) {
			return Response(http.StatusNotFound, nil), err
		}
		return Response(http.StatusInternalServerError, nil), err
	}

	openApiSong := SongDetail{
		ReleaseDate: resultSong.ReleaseDate.Format("2006-01-02"),
		Text:        resultSong.Text,
		Link:        resultSong.Link,
	}
	return Response(http.StatusOK, openApiSong), nil
}

// InfoPost - Create a new song
func (s *DefaultAPIService) InfoPost(ctx context.Context, group string, song string, songDetail SongDetail) (ImplResponse, error) {

	releaseDate, err := time.Parse("2006-01-02", songDetail.ReleaseDate)
	if err != nil {
		return Response(http.StatusBadRequest, nil), err
	}

	resultSong, err := s.songsProcessor.CreateSong(ctx, &domain.Song{
		ReleaseDate: releaseDate,
		Text:        songDetail.Text,
		Link:        songDetail.Link,
		GroupName:   group,
		SongName:    song,
	})
	if err != nil {
		return Response(http.StatusBadRequest, nil), err
	}

	openApiSong := SongDetail{
		ReleaseDate: resultSong.ReleaseDate.Format("2006-01-02"),
		Text:        resultSong.Text,
		Link:        resultSong.Link,
	}
	return Response(http.StatusCreated, openApiSong), nil
}

// InfoDelete - Delete an existing song
func (s *DefaultAPIService) InfoDelete(ctx context.Context, group string, song string) (ImplResponse, error) {

	err := s.songsProcessor.DeleteSong(ctx, group, song)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}
	if errors.Is(err, internal.ErrNotFound) {
		return Response(http.StatusNotFound, nil), err
	}
	if errors.Is(err, internal.ErrEmptyParams) {
		return Response(http.StatusBadRequest, nil), err
	}
	return Response(http.StatusNoContent, nil), nil

}
